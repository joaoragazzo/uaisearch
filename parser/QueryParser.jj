options {
    STATIC = false;
    IGNORE_CASE = false;
}

PARSER_BEGIN(QueryParser)
package com.elastic.aisearch.queryUnit;

import java.io.StringReader;
import java.util.*;
import lombok.Getter;

public class QueryParser {

    @Getter
    public class QueryNode {
        private String shouldContent = "";

        private List<String> mustNotContent = new ArrayList<>();
        private List<String> mustInContent = new ArrayList<>();

        private List<String> mustTitle = new ArrayList<>();
        private List<String> mustNotTitle = new ArrayList<>();

        private String minDate = "";
        private String maxDate = "";
        private String eqDate = "";

        private String minReadingTime = "";
        private String maxReadingTime = "";
        private String eqReadingTime = "";



        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("<b>shouldContent:</b> ").append(shouldContent).append("</br>");

            sb.append("<b>mustNotContent:</b> </br>");
            for (String s : mustNotContent) {
                sb.append("  - ").append(s).append("</br>");
            }

            sb.append("<b>mustInContent:</b> </br>");
            for (String s : mustInContent) {
                sb.append("  - ").append(s).append("</br>");
            }
            
            sb.append("</br>");

            sb.append("<b>mustTitle:</b> ").append("</br>");
            for (String s : mustTitle) {
                sb.append("  - ").append(s).append("</br>");
            }
            sb.append("<b>mustNotTitle:</b> ")  .append("</br>");
            for (String s : mustNotTitle) {
                sb.append("  - ").append(s).append("</br>");
            }

            sb.append("</br>");

            sb.append("<b>minDate:</b> ").append(minDate).append("</br>");
            sb.append("<b>maxDate:</b> ").append(maxDate).append("</br>");
            sb.append("<b>eqDate:</b> ").append(eqDate).append("</br>");

            sb.append("</br>");

            sb.append("<b>minReadingTime:</b> ").append(minReadingTime).append("</br>");
            sb.append("<b>maxReadingTime:</b> ").append(maxReadingTime).append("</br>");
            sb.append("<b>eqReadingTime:</b> ").append(eqReadingTime).append("</br>");

            return sb.toString();
        }

    }

    public QueryNode node = new QueryNode();

    public QueryNode parseQuery(String query) throws ParseException {
        ReInit(new StringReader(query));
        Start();
        return node;
    }
}
PARSER_END(QueryParser)

SKIP : {
      " " 
    | "\t" 
    | "\r" 
    | "\n"
}

TOKEN : {
      < OR: "OR" >
    | < READING_TIME: "reading_time:" >
    | < CREATED_AT: "created_at:" >
    | < IN_CONTENT: "in_content:" >
    | < IN_TITLE: "in_title:" >
    | < NOT_IN_TITLE: "-in_title:" >
    | < GT: ">" >
    | < LT: "<" >
    | < RANGE_DOTS: ".." >
    | < NUMBER: (["0"-"9"])+ >
    | < DATE: (["0"-"9"]){2} "/" (["0"-"9"]){2} "/" (["0"-"9"]){4} >     
    | < WORD: (["a"-"z", "A"-"Z", "0"-"9", "_", "-", "/"])+ >
    | < QUOTED: "\"" (~["\""])* "\"" >
}

void Start() : { Token word, quoted; }
{
    (
       word = < WORD > 
        {
            this.node.shouldContent += word.image + " ";
        }
    | quoted = < QUOTED > 
        {
            this.node.mustInContent.add(quoted.image);
        }
    | Filter()
    | word = < NUMBER > 
        {
            this.node.shouldContent += word.image + " ";
        }
    )+
}

void Filter() : { Token t1; }
{
    (
        <CREATED_AT> DateFilter()
      | <READING_TIME> ReadingTimeFilter()
      | <IN_TITLE> InTitleFilter(true)
      | <NOT_IN_TITLE> InTitleFilter(false)
    )
}

void DateFilter() : { Token d1, d2; }
{
    (
            <GT> d1 = <DATE> { this.node.minDate = d1.image; }
       |    <LT> d1 = <DATE> { this.node.maxDate = d1.image; }
       | 
            d1 = <DATE>
            [
                <RANGE_DOTS> d2 = <DATE> {
                    this.node.minDate = d1.image;
                    this.node.maxDate = d2.image;
                }
            ]
            {
                if(this.node.minDate.equals("")) { 
                    this.node.eqDate = d1.image;
                }
            }
    )
}

void ReadingTimeFilter() : { Token t1, t2; }
{
    (
            <GT> t1 = <NUMBER> { this.node.minReadingTime = t1.image; }
       |    <LT> t1 = <NUMBER> { this.node.maxReadingTime = t1.image; }
       | 
            t1 = <NUMBER>
            [
                <RANGE_DOTS> t2 = <NUMBER> {
                    this.node.minReadingTime = t1.image;
                    this.node.maxReadingTime = t2.image;
                }
            ]
            {
                if(this.node.minReadingTime.equals("")) { 
                    this.node.eqReadingTime = t1.image;
                }
            }
    )
}

void InTitleFilter(boolean must) : { Token t1; }
{
        t1 = <WORD>
        {
            if (must)
                this.node.mustTitle.add(t1.image);
            else
                this.node.mustNotTitle.add(t1.image);            
        }
    |   t1 = <QUOTED>
        {
            if (must)
                this.node.mustTitle.add(t1.image);
            else 
                this.node.mustNotTitle.add(t1.image);
        }
}


